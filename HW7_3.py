''''массив размером 2м +1, где м - натуральное число, заполнен случайным образом. Найдите в мессиве медиану.
Медианой называется элемент ряда, делящий его на 2 равные части: в одной находятся элементы, которые не меньше медианы,
в другой - не больше медианы.
прим.: задачу можно решить без сортировки исходного массива.
Но если это слишком сложно, используйте метод сортировки, который не рассматривался на уроках '''
import random
import statistics
import timeit

# постановка задачи
SIZE_M = 10
MIN_ITEM = 0
MAX_ITEM = 50
if SIZE_M % 2 == 0:
    SIZE_M += 1
array = [random.randint(MIN_ITEM, MAX_ITEM - 1) for _ in range(SIZE_M)]

print(f'Исходный массив:\n{array}')

def median(array, mid):
    '''Если мы не будем использовать сортировку, но представим что она произошла,
     то в массиве длиной 7, это будет 4й элемент, длиной 9----> 5й элемент.
    Соответсвенно параметр mid всегда должен быть центральным в отсортированном массиве.
    Таким образом, не сортируя массив нам достаточно найти элемент,
    который будет в массиве длиной 9 - пятым наименьшим элементом.
    То есть в массиве длиной M нам надо найти элемент который будет является (М//2+1) наименьшим в массиве
    Например:(9//2+1=5) те нам надо найти 5й наименьший элемент----->переменная mid = 5,
    те mid это порядковый номер наименьшего элемента.
    Каждый раз мы ищем mid-наименьший элемент массива, который и будет являться медианой.


    Выберем элемент (pivot) исходного массива (допустим он будет центральным элементом массива),
    далее сравним все элементы массива с выбранным, и те которые меньше занесем в один список, которые больше в другой,
    те которые совпадают в третий'''
    if len(array) < 2:  # базовым является случай когда массив состоит из 1 элемента
        return array[0]
    pivot = array[len(array)//2]
    lesser_pivot = [x for x in array if x < pivot]
    greater_pivot = [x for x in array if x > pivot]
    pivot_list = [x for x in array if x == pivot]
    #  возможны 3 варианта событий:
    #  1.если элементов, которые меньше выбранного (pivot) больше чем "mid", то медиана точно там.
    #  Рекурсивно дробим получившийся массив'''
    if len(lesser_pivot) >= mid:
        return median(lesser_pivot, mid)
    # 2. Когда искомый mid-наименьший элемент, меньше или равен сумме длины массива с выбранным элементом
    # и длины массива, в котором элементы меньше выбранного, то выбранный элемент является медианой.
    elif mid <= (len(pivot_list)+len(lesser_pivot)):
        return pivot
    # 3. Когда искомый mid-наименьший элемент больше чем массив с наименьшими элементами, значит его там нет,
    # будем искать в массиве с элементами, которые больше выбранного, но следует учесть что порядковый номер
    # наименьшего элемента уменьшится на длину массива lesser_pivot и длину pivot_list, что логично, потому что искать
    # допустим 5й наименьший элемент отбросив массив в котором уже были 3 наименьших массива будет ошибкой!
    else:
        return median(greater_pivot, mid - len(lesser_pivot) - len(pivot_list))


mid = len(array)//2+1

print(f'Результат:', median(array, mid))
print(f'Проверка:', statistics.median(array))  # ----> для проверки

# оценим время выполнения операции:

# print(timeit.timeit('median(array, mid)', number=1000, globals=globals()))  # 0.567709042-----> m = 1000
# print(timeit.timeit('statistics.median(array)', number=1000, globals=globals()))  # 0.14527091600000008-----> m = 1000


